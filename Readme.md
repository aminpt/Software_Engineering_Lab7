# آزمایش ۷ - الگوهای طراحی (Design Patterns)

## ۱. بخش اول: تشخیص زیرمسائل و انتخاب الگوها

با تحلیل کد اولیه `TicketService`، دو زیرمسئله اصلی شناسایی شد که طراحی فعلی (مبتنی بر شرط‌های تودرتو) را با مشکل مواجه کرده‌اند:

### زیرمسئله اول: نحوه محاسبه قیمت و ویژگی‌های انواع سفر
**۱. شرح مسئله:**
در سیستم فعلی، برای محاسبه قیمت بلیط یا دریافت توضیحات سفر، باید نوع وسیله نقلیه (اتوبوس، هواپیما و...) چک شود. این کار معمولاً با `if/else` یا `switch` انجام می‌شود. اگر نوع جدیدی اضافه شود، باید کد اصلی تغییر کند. همچنین این بخش مصداق "کاری است که می‌تواند به چند روش انجام شود".

**۲. الگوی پیشنهادی و دلیل:**
*   **الگو:** **Strategy (استراتژی)**
*   **دلیل:** طبق صورت مسئله، جاهایی که "کاری می‌تواند به چند روش انجام شود" کاندیدای این الگو هستند. این الگو الگوریتم‌های مختلف (محاسبه قیمت) را از کلاس اصلی جدا کرده و اجازه می‌دهد بدون تغییر کلاس اصلی، استراتژی‌ها را تغییر دهیم یا اضافه کنیم.

**۳. روش اعمال الگو:**
*   تعریف یک اینترفیس مشترک به نام `TravelStrategy` با متدهای `calculatePrice` و `getDescription`.
*   تعریف کلاس‌های جداگانه برای هر روش سفر (مانند `BusStrategy` و `FlightStrategy`) که این اینترفیس را پیاده‌سازی می‌کنند.
*   در کلاس اصلی (`Ticket`)، به جای متغیر از نوع `String` یا `Enum` برای نوع وسیله، یک فیلد از نوع `TravelStrategy` تعریف می‌کنیم (Composition).

---

### زیرمسئله دوم: مدیریت رفتار وابسته به وضعیت بلیط
**۱. شرح مسئله:**
بلیط مراحل مختلفی دارد (ثبت شده، پرداخت شده، لغو شده). رفتار سیستم در هر مرحله متفاوت است. مثلاً "پرداخت کردن" فقط زمانی مجاز است که بلیط "ثبت شده" باشد و اگر بلیط "لغو شده" باشد، نباید بتوان آن را پرداخت کرد. مدیریت این محدودیت‌ها با متغیرهای ساده و شرط‌های تودرتو پیچیده و خطازا است.

**۲. الگوی پیشنهادی و دلیل:**
*   **الگو:** **State (حالت)**
*   **دلیل:** طبق صورت مسئله، جاهایی که "رفتار سیستم وابسته به حالت آن است" کاندیدای این الگو هستند. این الگو باعث می‌شود شیء به نظر برسد که با تغییر وضعیت داخلی، کلاس خود را تغییر داده است و از شرط‌های پیچیده جلوگیری می‌کند.

**۳. روش اعمال الگو:**
*   تعریف یک اینترفیس به نام `TicketState` (یا `OrderState`) که متدهای رفتاری (مانند `pay` و `cancel`) را تعریف می‌کند.
*   تعریف کلاس‌های مجزا برای هر وضعیت: `OrderedState`، `PaidState` و `CancelledState` که اینترفیس را پیاده‌سازی می‌کنند.
*   کلاس اصلی (`Ticket`) دارای یک فیلد `currentState` می‌شود و درخواست‌های کاربر (مثل پرداخت) را به این شیء واگذار (Delegate) می‌کند تا آن شیء تصمیم بگیرد چه واکنشی نشان دهد یا به چه وضعیت جدیدی منتقل شود.

---

## ۲. بخش دوم: ترسیم Class Diagram
![class diagram](photos/class%20diagram.png)

---

## ۳. بخش سوم: اعمال الگو

بر روی کد ها اعمال شد.

---

## ۴. بخش چهارم: تحلیل شیء‌گرا


### اصل OCP (Open/Closed Principle)
در کد قبلی، برای اضافه کردن یک وسیلهٔ نقلیهٔ جدید (مثلا قطار)، لازم بود کد کلاس `TicketService` تغییر کند.  
اما در طراحی جدید و با رعایت اصل OCP، سیستم نسبت به توسعه باز و نسبت به تغییر بسته است. به‌طوری‌که تنها با اضافه‌کردن کلاس `TrainStrategy` می‌توان قابلیت جدید را بدون تغییر کدهای موجود به سیستم افزود.

### اصل SRP (Single Responsibility Principle)
در نسخهٔ اولیه، یک کلاس هم مسئول مدیریت وضعیت بود و هم مسئول محاسبه قیمت.  
در طراحی جدید، هر کلاس تنها یک وظیفه مشخص دارد:
- کلاس‌های `State` صرفا وضعیت سیستم را مدیریت می‌کنند.
- کلاس‌های `Strategy` تنها مسئول انجام محاسبات مربوط به سفر هستند.

### اصل DIP (Dependency Inversion Principle)
کلاس `TicketService` دیگر به پیاده‌سازی‌های مشخصی مانند `Bus` یا `Flight` وابسته نیست،  
بلکه به اینترفیس‌های انتزاعی مانند `TravelStrategy` وابسته است که باعث کاهش وابستگی و افزایش انعطاف‌پذیری سیستم می‌شود.

### اصول PLK و CRP
با استفاده از ترکیب (Composition) به‌جای وراثت (CRP)، وابستگی بین کلاس‌ها کاهش یافته است.  
همچنین کلاس اصلی فقط با همسایگان مستقیم خود (اینترفیس‌ها) در ارتباط است که نمونه‌ای از رعایت PLK محسوب می‌شود.
