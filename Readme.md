# آزمایش ۷ - الگوهای طراحی (Design Patterns)

## ۱. بخش اول: تشخیص زیرمسائل و انتخاب الگوها

با تحلیل کد اولیه `TicketService`، دو زیرمسئله اصلی شناسایی شد که طراحی فعلی (مبتنی بر شرط‌های تودرتو) را با مشکل مواجه کرده‌اند:

### زیرمسئله اول: نحوه محاسبه قیمت و ویژگی‌های انواع سفر
**۱. شرح مسئله:**
در سیستم فعلی، برای محاسبه قیمت بلیط یا دریافت توضیحات سفر، باید نوع وسیله نقلیه (اتوبوس، هواپیما و...) چک شود. این کار معمولاً با `if/else` یا `switch` انجام می‌شود. اگر نوع جدیدی اضافه شود، باید کد اصلی تغییر کند. همچنین این بخش مصداق "کاری است که می‌تواند به چند روش انجام شود".

**۲. الگوی پیشنهادی و دلیل:**
*   **الگو:** **Strategy (استراتژی)**
*   **دلیل:** طبق صورت مسئله، جاهایی که "کاری می‌تواند به چند روش انجام شود" کاندیدای این الگو هستند. این الگو الگوریتم‌های مختلف (محاسبه قیمت) را از کلاس اصلی جدا کرده و اجازه می‌دهد بدون تغییر کلاس اصلی، استراتژی‌ها را تغییر دهیم یا اضافه کنیم.

**۳. روش اعمال الگو:**
*   تعریف یک اینترفیس مشترک به نام `TravelStrategy` با متدهای `calculatePrice` و `getDescription`.
*   تعریف کلاس‌های جداگانه برای هر روش سفر (مانند `BusStrategy` و `FlightStrategy`) که این اینترفیس را پیاده‌سازی می‌کنند.
*   در کلاس اصلی (`Ticket`)، به جای متغیر از نوع `String` یا `Enum` برای نوع وسیله، یک فیلد از نوع `TravelStrategy` تعریف می‌کنیم (Composition).

---

### زیرمسئله دوم: مدیریت رفتار وابسته به وضعیت بلیط
**۱. شرح مسئله:**
بلیط مراحل مختلفی دارد (ثبت شده، پرداخت شده، لغو شده). رفتار سیستم در هر مرحله متفاوت است. مثلاً "پرداخت کردن" فقط زمانی مجاز است که بلیط "ثبت شده" باشد و اگر بلیط "لغو شده" باشد، نباید بتوان آن را پرداخت کرد. مدیریت این محدودیت‌ها با متغیرهای ساده و شرط‌های تودرتو پیچیده و خطازا است.

**۲. الگوی پیشنهادی و دلیل:**
*   **الگو:** **State (حالت)**
*   **دلیل:** طبق صورت مسئله، جاهایی که "رفتار سیستم وابسته به حالت آن است" کاندیدای این الگو هستند. این الگو باعث می‌شود شیء به نظر برسد که با تغییر وضعیت داخلی، کلاس خود را تغییر داده است و از شرط‌های پیچیده جلوگیری می‌کند.

**۳. روش اعمال الگو:**
*   تعریف یک اینترفیس به نام `TicketState` (یا `OrderState`) که متدهای رفتاری (مانند `pay` و `cancel`) را تعریف می‌کند.
*   تعریف کلاس‌های مجزا برای هر وضعیت: `OrderedState`، `PaidState` و `CancelledState` که اینترفیس را پیاده‌سازی می‌کنند.
*   کلاس اصلی (`Ticket`) دارای یک فیلد `currentState` می‌شود و درخواست‌های کاربر (مثل پرداخت) را به این شیء واگذار (Delegate) می‌کند تا آن شیء تصمیم بگیرد چه واکنشی نشان دهد یا به چه وضعیت جدیدی منتقل شود.

---
